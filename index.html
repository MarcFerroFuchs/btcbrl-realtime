<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BTC/BRL • Gráfico em Tempo Real (1m)</title>
  <!-- Lightweight Charts (TradingView) -->
  <script defer src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
  <style>
    :root {
      --bg: #0b0b0b;
      --fg: #e6e6e6;
      --muted: #9aa0a6;
      --up: #2ecc71;
      --down: #e74c3c;
      --panel: #111214;
    }
    html, body {
      margin: 0;
      height: 100%;
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
    }
    .wrap {
      display: grid;
      grid-template-rows: auto 1fr auto;
      height: 100%;
    }
    header, footer {
      padding: 10px 14px;
      background: var(--panel);
      border-bottom: 1px solid #1a1b1e;
    }
    footer { border-top: 1px solid #1a1b1e; border-bottom: none; }
    .row {
      display: flex; align-items: center; gap: 12px; flex-wrap: wrap;
    }
    .pair { font-weight: 700; letter-spacing: .3px; }
    .pill {
      padding: 4px 10px; border-radius: 999px; background: #16181c; color: var(--muted);
      border: 1px solid #22242a; font-size: 12px;
    }
    .price { font-weight: 800; font-size: 20px; letter-spacing: .3px; }
    .chg.up { color: var(--up); }
    .chg.down { color: var(--down); }
    #chart { width: 100%; height: calc(100vh - 120px); }
    .status { font-size: 12px; color: var(--muted); }
    a { color: #8ab4f8; text-decoration: none; }
    .dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; margin-right: 6px; background:#888; }
    .dot.live { background: #3ddc97; }
    .dot.off { background: #bf616a; }
  </style>
</head>
<body>
  <div class="wrap">
    <header class="row">
      <div class="pair">BTC/BRL</div>
      <div class="pill">Intervalo: 1m</div>
      <div id="live-dot" class="dot off"></div><span id="conn" class="status">Conectando…</span>
      <div style="flex:1"></div>
      <div class="price" id="last">—</div>
      <div id="change" class="pill chg">—</div>
    </header>

    <div id="chart"></div>

    <footer class="row">
      <div class="status" id="hint">Dados públicos da Binance (somente leitura). Atualiza a cada novo candle/negócio.</div>
      <div style="flex:1"></div>
      <div class="status">Dica: passe o mouse para ver OHLC; role para zoom; arraste para navegar.</div>
    </footer>
  </div>

  <script>
    // ======= Configurações =======
    const SYMBOL = 'BTCBRL';
    const INTERVAL = '1m'; // 1 minuto
    const HISTORY_LIMIT = 500; // quantidade de candles iniciais
    const REST_BASE = 'https://api.binance.com';
    const WS_URL = `wss://stream.binance.com:9443/ws/${SYMBOL.toLowerCase()}@kline_1m`;

    // ======= UI Elements =======
    const elLast = document.getElementById('last');
    const elChange = document.getElementById('change');
    const elConn = document.getElementById('conn');
    const dot = document.getElementById('live-dot');
    const elHint = document.getElementById('hint');

    function setConn(status, live) {
      elConn.textContent = status;
      dot.classList.toggle('live', !!live);
      dot.classList.toggle('off', !live);
    }

    // ======= Chart =======
    const chart = LightweightCharts.createChart(document.getElementById('chart'), {
      layout: {
        background: { color: getComputedStyle(document.documentElement).getPropertyValue('--bg').trim() },
        textColor: getComputedStyle(document.documentElement).getPropertyValue('--fg').trim(),
        fontSize: 12,
      },
      rightPriceScale: { borderColor: '#2a2d34' },
      timeScale: { borderColor: '#2a2d34', fixLeftEdge: false, fixRightEdge: false, rightOffset: 6, barSpacing: 8 },
      grid: {
        vertLines: { color: '#15171a' },
        horzLines: { color: '#15171a' },
      },
      crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
      autoSize: true,
    });

    const candleSeries = chart.addCandlestickSeries({
      upColor: getComputedStyle(document.documentElement).getPropertyValue('--up').trim(),
      downColor: getComputedStyle(document.documentElement).getPropertyValue('--down').trim(),
      borderUpColor: getComputedStyle(document.documentElement).getPropertyValue('--up').trim(),
      borderDownColor: getComputedStyle(document.documentElement).getPropertyValue('--down').trim(),
      wickUpColor: getComputedStyle(document.documentElement).getPropertyValue('--up').trim(),
      wickDownColor: getComputedStyle(document.documentElement).getPropertyValue('--down').trim(),
    });

    const lastPriceLine = chart.addLineSeries({ lastValueVisible: true, priceLineVisible: false, lineWidth: 1 });
    let lastBarTime = null;
    let dayOpen = null;

    window.addEventListener('resize', () => chart.timeScale().fitContent());

    // ======= Helpers =======
    const toNum = v => Number.parseFloat(v);

    function fmtBRL(n) {
      try {
        return n.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL', maximumFractionDigits: 2 });
      } catch {
        return `R$ ${n.toFixed(2)}`;
      }
    }

    function setPriceUI(price) {
      elLast.textContent = fmtBRL(price);
      if (dayOpen != null) {
        const pct = ((price - dayOpen) / dayOpen) * 100;
        elChange.textContent = `${pct >= 0 ? '+' : ''}${pct.toFixed(2)}%`;
        elChange.classList.toggle('up', pct >= 0);
        elChange.classList.toggle('down', pct < 0);
      }
      lastPriceLine.update({ time: Math.floor(Date.now()/1000), value: price });
    }

    // ======= Load initial data (history + 24h ticker) =======
    async function loadInitial() {
      setConn('Carregando histórico…', false);
      const klinesUrl = `${REST_BASE}/api/v3/klines?symbol=${SYMBOL}&interval=${INTERVAL}&limit=${HISTORY_LIMIT}`;
      const tickerUrl = `${REST_BASE}/api/v3/ticker/24hr?symbol=${SYMBOL}`;
      try {
        const [klRes, tkRes] = await Promise.all([fetch(klinesUrl), fetch(tickerUrl)]);
        if (!klRes.ok) throw new Error('Falha ao carregar klines');
        if (!tkRes.ok) throw new Error('Falha ao carregar ticker');

        const klines = await klRes.json();
        const ticker = await tkRes.json();

        // 24h open para % de variação
        dayOpen = toNum(ticker.openPrice);

        const data = klines.map(k => ({
          time: Math.floor(k[0] / 1000), // open time (s)
          open: toNum(k[1]),
          high: toNum(k[2]),
          low:  toNum(k[3]),
          close: toNum(k[4]),
        }));

        candleSeries.setData(data);
        chart.timeScale().fitContent();

        const last = data[data.length - 1];
        lastBarTime = last.time;
        setPriceUI(last.close);

        setConn('Conectando ao fluxo em tempo real…', false);
        openWS();
      } catch (err) {
        console.error(err);
        setConn('Erro ao carregar dados iniciais. Tente recarregar a página.', false);
        elHint.textContent = 'Não foi possível obter histórico inicial.';
      }
    }

    // ======= WebSocket realtime (kline 1m) =======
    let ws;
    let reconnectTimer;

    function openWS() {
      clearTimeout(reconnectTimer);
      ws = new WebSocket(WS_URL);

      ws.onopen = () => {
        setConn('Ao vivo', true);
      };

      ws.onmessage = (ev) => {
        const msg = JSON.parse(ev.data);
        const k = msg.k; // objeto kline
        const t = Math.floor(k.t / 1000); // abertura do candle (s)
        const bar = {
          time: t,
          open: toNum(k.o),
          high: toNum(k.h),
          low:  toNum(k.l),
          close: toNum(k.c),
        };

        // Atualiza candle corrente ou insere novo
        if (lastBarTime === t) {
          candleSeries.update(bar);
        } else if (lastBarTime == null || t > lastBarTime) {
          candleSeries.update(bar);
          lastBarTime = t;
        }

        setPriceUI(bar.close);
      };

      ws.onclose = () => {
        setConn('Desconectado. Tentando reconectar…', false);
        reconnectTimer = setTimeout(openWS, 1500);
      };

      ws.onerror = () => {
        setConn('Erro no fluxo. Tentando reconectar…', false);
        try { ws.close(); } catch {}
      };
    }

    // Start
    loadInitial();
  </script>
</body>
</html>

