<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BTC/BRL • Candle 1m</title>

  <!-- Preconnect para reduzir latência -->
  <link rel="preconnect" href="https://api.binance.com">
  <link rel="preconnect" href="https://data.binance.com">
  <link rel="preconnect" href="https://cdn.jsdelivr.net">
  <link rel="dns-prefetch" href="https://api.binance.com">
  <link rel="dns-prefetch" href="https://data.binance.com">
  <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">

  <style>
    :root { --bg:#0b0b0b; --fg:#e6e6e6; --up:#2ecc71; --down:#e74c3c; }
    html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
    #chart{position:fixed;inset:0}
  </style>

  <!-- Lightweight Charts (tenta jsDelivr e, se falhar, unpkg) -->
  <script>
    function loadScript(src, ok, fail){
      const s=document.createElement('script'); s.src=src; s.defer=true;
      s.onload=ok; s.onerror=fail; document.head.appendChild(s);
    }
    function boot(){
      if (window.LightweightCharts) return init();
      loadScript(
        "https://cdn.jsdelivr.net/npm/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js",
        ()=>init(),
        ()=>loadScript("https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js", ()=>init(), ()=>alert("Falha ao carregar biblioteca de gráfico."))
      );
    }
  </script>
</head>
<body>
  <div id="chart"></div>

  <script>
  async function init(){
    const SYMBOL = 'BTCBRL';
    const INTERVAL = '1m';
    const HISTORY_LIMIT = 300;

    // bases REST (usa a primeira que responder)
    const BASES = ['https://api.binance.com','https://data.binance.com'];
    let REST_BASE = BASES[0];

    async function pickBase(){
      for (const b of BASES){
        try { const r = await fetch(`${b}/api/v3/time`); if (r.ok) { REST_BASE=b; return; } } catch(e){}
      }
      throw new Error('Nenhuma base REST disponível.');
    }

    const css = getComputedStyle(document.documentElement);
    const COLOR_BG   = css.getPropertyValue('--bg').trim();
    const COLOR_FG   = css.getPropertyValue('--fg').trim();
    const COLOR_UP   = css.getPropertyValue('--up').trim();
    const COLOR_DOWN = css.getPropertyValue('--down').trim();

    // cria gráfico de tela inteira
    const chart = LightweightCharts.createChart(document.getElementById('chart'), {
      layout:{ background:{ color: COLOR_BG }, textColor: COLOR_FG, fontSize: 12 },
      rightPriceScale:{ borderColor:'#2a2d34' },
      timeScale:{ borderColor:'#2a2d34', rightOffset:6, barSpacing:8 },
      grid:{ vertLines:{ color:'#15171a' }, horzLines:{ color:'#15171a' } },
      crosshair:{ mode: LightweightCharts.CrosshairMode.Normal },
      autoSize:true,
    });
    const series = chart.addCandlestickSeries({
      upColor: COLOR_UP, downColor: COLOR_DOWN,
      borderUpColor: COLOR_UP, borderDownColor: COLOR_DOWN,
      wickUpColor: COLOR_UP, wickDownColor: COLOR_DOWN,
    });

    const j = url => fetch(url).then(r=>{ if(!r.ok) throw new Error(r.status); return r.json(); });

    await pickBase();

    // carrega histórico inicial
    const klines = await j(`${REST_BASE}/api/v3/klines?symbol=${SYMBOL}&interval=${INTERVAL}&limit=${HISTORY_LIMIT}`);
    const data = klines.map(k=>({
      time: Math.floor(k[0]/1000),
      open: +k[1], high: +k[2], low: +k[3], close: +k[4],
    }));
    series.setData(data);
    chart.timeScale().fitContent();

    let lastBarTime = data.length ? data[data.length-1].time : null;

    // polling da última vela a cada 3s
    setInterval(async ()=>{
      try{
        const [k] = await j(`${REST_BASE}/api/v3/klines?symbol=${SYMBOL}&interval=${INTERVAL}&limit=1`);
        const t = Math.floor(k[0]/1000);
        const bar = { time:t, open:+k[1], high:+k[2], low:+k[3], close:+k[4] };
        if (lastBarTime === t) {
          series.update(bar);
        } else if (lastBarTime == null || t > lastBarTime) {
          series.update(bar);
          lastBarTime = t;
        }
      }catch(e){
        // tenta alternar base silenciosamente
        try{
          const next = REST_BASE === BASES[0] ? BASES[1] : BASES[0];
          const r = await fetch(`${next}/api/v3/time`);
          if (r.ok) REST_BASE = next;
        }catch(_){}
      }
    }, 3000);
  }

  // inicia após injeção da lib
  boot();
  </script>
</body>
</html>
